
---
layout: post
title: "Role Based Authorization in React"
description: "Authorization is very crucial in your apps. A blog author should be prevented from deleting other's blogs. Read on to know how to implement this in react."
date: "2018-08-06 08:30"
author:
  name: "Aditya Agarwal"
  url: "dev__adi"
  mail: "adityaa803@gmail.com"
  avatar: "https://twitter.com/dev__adi/profile_image?size=original"
related:
- 2017-11-15-an-example-of-all-possible-elements
---

**TL;DR:** This is a guide for implementing role based authorization. Learn how to customize the app experience based on each user. All the code is available on [github](https://github.com/itaditya/react-rbac-auth0-article-code).

## Introduction

Web apps are everywhere and many tasks can be performed on the frontend now. However, not all tasks should be available to every user since each user is not equal, some are admins with special privileges and some are normal users. Web apps should be smart enough to distinguish between the two.

Role Based Access Control (RBAC) is a very popular method to achieve this. This article will be a guide on RBAC and also explain how to implement  RBAC in a [React](https://reactjs.org/) app using [Auth0](https://auth0.com/) and the new [React Context](https://reactjs.org/docs/context.html).

## What is Authorization.

Authorization is a process in which we control the access of information by users and also limit the actions users can perform.

An authenticated user is a user whose identity has been confirmed. It doesn't deal with access control. Authorization takes care of access control. It denies access to certain parts of the app based on various schemes. Without proper authorization, a user can cause havoc in an app. A writer could delete other writer's articles or change their password. This is why authorization is as important as authentication.

## Scope of Authorization in a React App.

Since many of the heavy lifting is now performed on the client side, the scope of authorization has now increased more than ever.

A solid authorization system has to -
* Limit the AJAX requests performed.
* Deny access to certain client side routes.
* Display or hide certain pieces of UI.

Suppose we are building the next [Medium](https://medium.com/).  When we visit our profile page, only we should see the Edit Profile button, others who visit our profile page shouldn't.

## Authorization system in a blogging app
Let's get a deeper understanding of authorization by building a blogging app in React.

The blogging app has these requirements-
1. There are two pages, Home and Dashboard.
1. Home page will show a list of all posts written and can be visited by anyone without even logging in.
1. Dashboard page will show the logged in user details and a list of all posts written. The page can be visited by writers and admins only.
1. Writers can edit their posts only but admins can edit and delete any post.

To implement this, we need to authenticate a user and allot a role to the user. Based on the role, we can choose to render the edit and delete buttons. On the same basis we can redirect users from dashboard route to home route if no user is currently logged in.

We'll use Auth0 to quickly add authentication in our react app without any need for backend.

**Note-** Authorization in this tutorial doesn't depend on Auth0. Skip the auth0 part if you already have an authentication system in place and just want to know more about Authorization and ACL.

## Authentication in React App with Auth0

Let's make a React app with CRA like this

```bash
$ create-react-app rbac-tutorial-app
```

Now `cd` into the newly created project and then create these files and folders so the directory structure looks like

![Folder Structure](/1-initial-folder-structure.png)

*Notice, we have deleted the App.js, App.css and App.test.js*

The directory structure is such that
* The components directory will hold all the reusable components.
* For each route there will be a component in pages directory.

Next open `src/index.js` and paste this code.

```js
import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';

import HomePage from './pages/home';
import DashboardPage from './pages/dashboard';

function App() {
  return (
    <div className="App container">
      <div className="jumbotron">
        <Router>
          <Switch>
            <Route exact path="/" component={HomePage} />
            <Route path="/dashboard" component={DashboardPage} />
            <Route path="/callback" component={CallbackPage} />
          </Switch>
        </Router>
      </div>
    </div>
  );
}

const rootElement = document.getElementById('root');
ReactDOM.render(<App />, rootElement);
```

It defines two routes, one for home and one for dashboard.

Now let's code both the pages. Open `src/pages/home.js` and paste this

```js
import React from 'react';

const HomePage = () => (
  <h2>Home</h2>
)

export default HomePage;
```
Similarly in `src/pages/dashboard.js` place this code

```js
import React from 'react';

const DashboardPage = () => (
  <h2>Dashboard</h2>
)

export default DashboardPage;
```

With that covered, let's fire up the local dev server with `$ npm start`. It will run the app in browser on port 3000.

On visiting http://localhost:3000, the page will have a heading of **Home** and on visiting http://localhost:3000/dashboard the heading will be **Dashboard**.

Now we'll add authentication with Auth0 in the react app.

### Create Auth0 application

Create an Auth0 account if there isn't one then go to the [Applications](https://manage.auth0.com/#/applications) page and create a new application. Name it **rbac-tutorial-app** and select **Single Page Web Application** type.

Go to Settings Tab. There in the **Allowed Callback URLs** field put http://localhost:3000/callback and save it. Auth0 will redirect users to this url after authenticating them. Also keep the **Client ID** handy as we will use it later.

### Configure Auth0 to assign a role to user

Auth0 provides a way to assign roles to a user. Auth0 runs a function everytime someone logs in. We can customise the function code to suit our requirements.

First go to the application dashboard and click on the **Rules** link in the sidebar. Then click on **Create Rule** button.

Now pick the  **Set roles to a user** under the **Access Control** heading. There we have to paste this code.

```js
function (user, context, callback) {
  user.app_metadata = user.app_metadata || {};

  if (user.email === 'your-email-id@gmail.com') {
    user.app_metadata.role = 'admin';
  } else {
    user.app_metadata.role = 'writer';
  }

  auth0.users.updateAppMetadata(user.user_id, user.app_metadata)
    .then(() => {
      context.idToken['https://rbac-tutorial-app/role'] = user.app_metadata.role;
      callback(null, user, context);
    })
    .catch((err) => {
      callback(err);
    });
}
```

We have told Auth0 to assign admin role to user with email your-email-id@gmail.com (Change the email id with yours). All other users will be assigned writer role.

### Integrate Auth0 with React app

Let's add the auth0 library.

```bash
$ npm install auth0-js
```

Next create a file  named `auth0-variables.js` inside `src/constants`  directory.

```js
export const AUTH_CONFIG = {
  domain: "rbac-tutorial-app.auth0.com",
  roleUrl: "https://rbac-tutorial-app/role",
  clientId: "your-app-client-id",
  callbackUrl: "http://localhost:3000/callback"
};
```

Now we have to import `auth0-js` and configure it. The task is very simple.

```js
import auth0 from "auth0-js";

import { AUTH_CONFIG } from "../constants/auth0-variables";

const auth = new auth0.WebAuth({
  domain: AUTH_CONFIG.domain,
  clientID: AUTH_CONFIG.clientId,
  redirectUri: AUTH_CONFIG.callbackUrl,
  audience: `https://${AUTH_CONFIG.domain}/userinfo`,
  responseType: "token id_token"
});
```

The `auth` instance provides methods to start the login process, get user details etc. However, there is one complication, we have to provide this auth instance to multiple react components. There are many ways to solve this but we'll use the new Context Api.

Create a file named `authContext.js` inside `src/` directory.

```js
import { createContext } from "react";

const authContext = createContext({
  authenticated: false, // to check if authenticated or not
  user: {}, // store all the user details
  accessToken: "", // accessToken of user for auth0
  initiateLogin: () => {}, // to start the login process
  handleAuthentication: () => {}, // handle auth0 login process
  logout: () => {} // logout the user
});

export const AuthProvider = authContext.Provider;
export const AuthConsumer = authContext.Consumer;
```

It very clearly shows the data and methods that will be available via `authContext`.

Next, we'll make a `Auth` component that will provide it's children access to `authContext`. Create a file named `Auth.js` inside `src/components` directory.

```js
import React, { Component } from "react";
import auth0 from "auth0-js";

import { AUTH_CONFIG } from "../constants/auth0-variables";
import { AuthProvider } from "../authContext";

const auth = new auth0.WebAuth({
  domain: AUTH_CONFIG.domain,
  clientID: AUTH_CONFIG.clientId,
  redirectUri: AUTH_CONFIG.callbackUrl,
  audience: `https://${AUTH_CONFIG.domain}/userinfo`,
  responseType: "token id_token"
});

class Auth extends Component {
  state = {
    authenticated: false,
    user: {
      role: "visitor"
    },
    accessToken: ""
  };

  initiateLogin = () => {
  };

  logout = () => {
  };

  handleAuthentication = () => {
  };

  setSession(authResult) {
  }

  render() {
    const authProviderValue = {
      ...this.state,
      initiateLogin: this.initiateLogin,
      handleAuthentication: this.handleAuthentication,
      logout: this.logout
    };
    return (
      <AuthProvider value={authProviderValue}>
        {this.props.children}
      </AuthProvider>
    );
  }
}

export default Auth;
```

This is a basic skeleton of the `Auth` component. We store the data inside state and assign `AuthProvider` the state and methods we want to share with children components of `Auth`. Let's implement all the methods.

```js
initiateLogin = () => {
  auth.authorize();
};
```

`auth` instance has an `authorize` method. `initiateLogin` is just a wrapper around it. When the `authorize` method is called, a login page is shown. When the user fills the form, Auth0 redirects the user back to our app at `http://localhost:3000/callback`. The redirect url contains some important information for our app. The `handleAuthentication` method parses the url.

```js
handleAuthentication = () => {
  auth.parseHash((error, authResult) => {
    if (error) {
      console.log(error);
      console.log(`Error ${error.error} Occured`);
      return;
    }

    this.setSession(authResult);
  });
};
```

After parsing the url it calls the `setSession` method to gather user data and store it.

```js
setSession(authResult) {
  const { accessToken } = authResult;
  auth.client.userInfo(accessToken, (error, data) => {
    if (error) {
      console.log("Error Occured", error);
      this.setState({
        authenticated: false,
        accessToken: "",
        user: {
          role: "visitor"
        }
      });
      return;
    }

    const user = {
      id: data.sub,
      email: data.email,
      role: data[AUTH_CONFIG.roleUrl]
    };
    
  console.log(user);
  
    this.setState({
      authenticated: true,
      accessToken,
      user
    });
  });
}
```

The `setSession` is a private method which uses the `accessToken` field provided by `handleAuthentication` to fetch user data from Auth0 server via `auth.client.userInfo` method. The server provides details like email and role. The role received is the one computed by the function we saved on Auth0 dashboard. In our case, it will be available via `data["https://rbac-tutorial-app/role"]`. All the necessary user data are stored in `Auth` component's state. We are also logging the user data because the user id will be important later.

Finally, to log the user out we just delete the stored user data in the state and revert the role to **visitor**.

```js
logout = () => {
  this.setState({
    authenticated: false,
    user: {
      role: "visitor"
    },
    accessToken: ""
  });
};
```

The `Auth` component will now look like [this](https://github.com/itaditya/react-rbac-auth0-article-code/blob/master/src/components/Auth.js).

With that covered, let's use the `Auth` component in our React app.  In the `src/index.js` wrap all the routing inside the `Auth` component. We will also add a route for the url `http://localhost:3000/callback` so that when Auth0 redirects the user back to this url, we can run the `handleAuthentication` method.

```js
import React from "react";
import ReactDOM from "react-dom";
import { BrowserRouter as Router, Route, Switch } from "react-router-dom";

import HomePage from "./pages/home";
import DashboardPage from "./pages/dashboard";
import CallbackPage from "./pages/callback";
import Auth from "./components/Auth";

function App() {
  return (
    <div className="App container">
      <Auth>
        <div className="jumbotron">
          <Router>
            <Switch>
              <Route exact path="/" component={HomePage} />
              <Route path="/dashboard" component={DashboardPage} />
              <Route path="/callback" component={CallbackPage} />
            </Switch>
          </Router>
        </div>
      </Auth>
    </div>
  );
}

const rootElement = document.getElementById("root");
ReactDOM.render(<App />, rootElement);
```

Create a file named `callback.js` inside `src/pages` directory. When users are redirected to this page, we check if the url contains important information. If it does, we call the `handleAuthentication` method provided by the `authContext`. It can be implemented like this.

```js
import React from "react";
import { Redirect } from "react-router-dom";

import { AuthConsumer } from "../authContext";

const Callback = props => (
  <AuthConsumer>
    {({ handleAuthentication }) => {
      if (/access_token|id_token|error/.test(props.location.hash)) {
        handleAuthentication();
      }
      return <Redirect to="/" />;
    }}
  </AuthConsumer>
);

export default Callback;
```

Now let's quickly implement the Login and Logout buttons as components.

Login.js

```js
// src/components/Login.js

import React from "react";

import { AuthConsumer } from "../authContext";

const Login = () => (
  <AuthConsumer>
    {({ initiateLogin }) => (
      <button className="btn btn-sm btn-primary" onClick={initiateLogin}>
        Login
      </button>
    )}
  </AuthConsumer>
);

export default Login;
```

Logout.js

```js
// src/components/Logout.js

import React from "react";

import { AuthConsumer } from "../authContext";

const Logout = () => (
  <AuthConsumer>
    {({ logout }) => (
      <button className="btn btn-sm btn-default" onClick={logout}>
        Logout
      </button>
    )}
  </AuthConsumer>
);

export default Logout;
```

The Home page should have the Login component.

```js
import React from "react";
import { Redirect } from "react-router-dom";

import { AuthConsumer } from "../authContext";
import Login from "../components/Login";
import PostsList from "../components/PostsList";

const HomePage = () => (
  <AuthConsumer>
    {({ authenticated }) =>
      authenticated ? (
        <Redirect to="/dashboard" />
      ) : (
        <div>
          <h2>Welcome to React RBAC Tutorial.</h2>
          <Login />
          <PostsList />
        </div>
      )
    }
  </AuthConsumer>
);

export default HomePage;
```

Here, we are checking if user is authenticated. If they are we redirect them to Dashboard page otherwise we show the `Login` button component and the `PostList` component (will be implemented later).


## Basic Way to do Authorization

We can use the user role and place `if` statements to conditionally render certain parts of UI. It can look like this

```js
renderButton(user) {
  const markup = [];
  if(user.role === 'admin' || user.role === 'writer') {
    markup.push(
      <button>
        Action Button
      </button>
    )
  } else {
    markup.push(
      <span>Action Not Allowed</span>
    )
  }
  return markup;
}
```

This can get the job done but there are many small issues hidden here that will show their ugly face when we scale. Let's look at each one.

### Flaws

1. When requirements change, we'll have to check each and every condition related to authorization and may have to update them. This is not at all scalable.
1. For each new role added, the whole codebase has to be modified.
1. Code is imperative whereas React preaches decalarative code as it is easier to follow.
1. There is more room for bugs to hide. As more conditions are added to accommodate the authorization logic, more conditional expressions will have to be placed. Having a combination of those can quickly become overwhelming. There might be unknown effects of the combination of these conditionals. It might happen that because we add a new role, the resulting logic now allows access to visitor also which wasn't desired. Proper tests can catch them but there must be better ways.
1. Code duplication occurs at a lot of places.

## Better Solution (RBAC Authorization)

RBAC Authorization is a great way to solve these issues. Let's look into it in more detail.

### What is RBAC

RBAC is an acronym for Role Based Access Control. It is a scheme in which we define some roles and then each user is assigned a role. Each role has some permissions associated with it. All these permissions are defined at one place. To check if some information can be accessed, it is checked if the role of the user has the necessary permissions.

### Advantages of RBAC

1. Since all the permissions are at one place, when requirements change we just have to add or remove permissions of the roles.
1. Creating new roles is very easy.
1. Favors declarative programming because all the roles and the permissions associated with them are explicitly defined.

## Implementation of RBAC

### Make a file containing all the rules

The rules declare what permissions each role have. There will be two types of permissions for each user role, static and dynamic. Static permissions are those permissions which don't need any data apart from user role. Dynamic permissions are permissions which need additional data to determine access. Static permissions are helpful when say we have to allow write access to writers and admins only. Dynamic permissions are helpful when say we have to only allow the writer who is the owner of a resource to edit that resource.

Create a file named `rbac-rules.js` inside `src/constants` folder. 

```js
const rules = {
  visitor: {
    static: ["posts:list", "home-page:visit"]
  },
  writer: {
    static: [
      "posts:list",
      "posts:create",
      "users:getSelf",
      "home-page:visit",
      "dashboard-page:visit"
    ],
    dynamic: {
      "posts:edit": ({ userId, postOwnerId }) => {
        if (!userId || !postOwnerId) return false;
        return userId === postOwnerId;
      }
    }
  },
  admin: {
    static: [
      "posts:list",
      "posts:create",
      "posts:edit",
      "posts:delete",
      "users:get",
      "users:getSelf",
      "home-page:visit",
      "dashboard-page:visit"
    ]
  }
};

export default rules;
```

A permission can be in any format but it is very important to stay consistent. Here we have the format `resource:action`. We have duplicated a permission in multiple roles but we can avoid it by using object spread.

```js
const adminPermissions = {
 static: {
   ...visitorPermissions.static,
   "users:get",
   "users:getSelf"
 }
}
```

Next, let's make a component which can use these rules to determine access.

### Implement Can component

Can component takes the RBAC rules and decide that given some data, can the user perform a task or can they see some part of UI. If the user can perform the task, the Can component renders the **yes** render prop otherwise the **no** render prop. It can be implemented like this.

```js
import rules from "../constants/rbac-rules";

const check = (rules, role, action, data) => {
  const permissions = rules[role];
  if (!permissions) {
    // role is not present in the rules
    return false;
  }

  const staticPermissions = permissions.static;

  if (staticPermissions && staticPermissions.includes(action)) {
    // static rule not provided for action
    return true;
  }

  const dynamicPermissions = permissions.dynamic;

  if (dynamicPermissions) {
    const permissionCondition = dynamicPermissions[action];
    if (!permissionCondition) {
      // dynamic rule not provided for action
      return false;
    }

    return permissionCondition(data);
  }
};

const Can = props =>
  check(rules, props.role, props.perform, props.data)
    ? props.yes()
    : props.no();

Can.defaultProps = {
  yes: () => null,
  no: () => null
};

export default Can;
```

`check()` functon imperatively checks if the user has the permission, if so it returns true otherwise false and this returned value is used by the `Can` component to declaratively render appropriate render prop. In the `check()` function, first we find if the permission is present in the `staticPermissions` array of the user role. If it is then user has the permission. If it is not present then we check if `dynamicPermissions` has a key same as the permission, if there is, we call the method associated with that key and uses the returned value of the method to find if user has the permission or not.

### Use the Can component

Using the Can component is very easy. We pass the **role** prop and **perform** prop to tell the `Can` component what is the user role and what action has to be performed. Then we provide the **yes** and **no** render prop. If the logged in user can perform the action, then the "User can do it" heading will be rendered otherwise the "User can't do it" heading will be rendered.

```js
<Can
  role={user.role}
  perform="dashboard-page:visit"
  yes={() => (
    <h2>User can do it</h2>
  )}
  no={() => <h2>User can't do it</h2>}
/>
```

With that information, let's take advantage of it in the dashboard page.

```js
import React from "react";
import { Redirect } from "react-router-dom";

import { AuthConsumer } from "../authContext";
import Can from "../components/Can";
import Logout from "../components/Logout";
import Profile from "../components/Profile";
import PostsList from "../components/PostsList";

const DashboardPage = () => (
  <AuthConsumer>
    {({ user }) => (
      <Can
        role={user.role}
        perform="dashboard-page:visit"
        yes={() => (
          <div>
            <h1>Dashboard</h1>
            <Logout />
            <Profile />
            <PostsList />
          </div>
        )}
        no={() => <Redirect to="/" />}
      />
    )}
  </AuthConsumer>
);

export default DashboardPage;
```

We check if the user can perform **dashboard-page:visit**. If yes, render the dashboard page content like Logout button, Profile data, list of Posts etc. If no, redirect the user to home page.

Logout button component has already been implemented so now let's implement `PostsList` component and `Profile` component.

The `PostsList` component renders a table containing list of all posts. The posts written by the user logged in will show an Edit button alongside them. Admins are shown Edit button and Delete button for all the posts. Let's see how `PostsList` component can be implemented.

```js
import React from "react";

import posts from "../constants/posts";
import { AuthConsumer } from "../authContext";
import Can from "./Can";

const PostsList = () => (
  <AuthConsumer>
    {({ user }) => (
      <div>
        <h2>Posts List</h2>
        <table className="table">
          <thead>
            <tr>
              <th scope="col">#</th>
              <th scope="col">Title</th>
              <th scope="col">Actions</th>
            </tr>
          </thead>
          <tbody>
            {posts.map((post, index) => (
              <tr key={post.id}>
                <th scope="row">{index + 1}</th>
                <td>{post.title}</td>
                <td>
                  <Can
                    role={user.role}
                    perform="posts:edit"
                    data={{
                      userId: user.id,
                      postOwnerId: post.ownerId
                    }}
                    yes={() => (
                      <button className="btn btn-sm btn-default">
                        Edit Post
                      </button>
                    )}
                  />
                  <Can
                    role={user.role}
                    perform="posts:delete"
                    yes={() => (
                      <button className="btn btn-sm btn-danger">
                        Delete Post
                      </button>
                    )}
                  />
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    )}
  </AuthConsumer>
);

export default PostsList;
```

It imports an array of posts from `posts.js` module. Then we iterate through the array and render table rows. In the table row we use the Can component twice, one for Edit button and another for Delete button. Since the **no** render prop is not provided it will default to `null` so in place of the buttons nothing else will be rendered. For the Edit button we also pass additional data to Can component. This is because the owner of the post should also see the Edit button and that is a dynamic permission.

Let's implement `posts.js` also. The file should be kept in `src/constants` folder.

```js
/*
** Change the ownerId with the ones you get on login **
*/

const posts = [
  {
    id: "a",
    title: "Post a",
    ownerId: ""
  },
  {
    id: "b",
    title: "Post b",
    ownerId: ""
  },
  {
    id: "c",
    title: "Post c",
    ownerId: ""
  },
  {
    id: "d",
    title: "Post d",
    ownerId: ""
  }
];

export default posts;
```

We will login with different emails to make multiple user accounts and we'll make the user, owner of certain posts by copying the user id in the `ownerId` field. The user's id can be found in the Console tab when we log in (due to the `console.log()` in `setSession()` method of `Auth` component).

`Profile` component takes user data from context and render the appropriate markup. It can be implemented like this

```js
import React from "react";

import { AuthConsumer } from "../authContext";

const Profile = () => (
  <AuthConsumer>
    {({ user }) => (
      <div>
        <h2>User Profile</h2>
        <ul>
          <li>ID: {user.id}</li>
          <li>Email: {user.email}</li>
          <li>Role: {user.role}</li>
        </ul>
      </div>
    )}
  </AuthConsumer>
);

export default Profile;
```

With all of the implementation covered, let's check if everything works properly. Open http://localhost:3000/. There we'll see a login button and a tabular list of posts. Since we haven't logged in yet, our role will default to visitor. Visitors are not allowed to edit or delete the posts so no edit and delete buttons will be shown.

Now let's check what will happen when we have **admin** role. Click on Login button to start the login process. We configured Auth0 to assign admin role to a particular email-id so we'll use that email-id while logging in. After successful login, we should be redirected to dashboard page. There we'll see the logout button and a list of posts which have edit and delete buttons alongside them.

At last, we have to check the case when a **writer** logs in. Log in with a user account who is owner of some posts. Now only the posts which were written by that writer will have an Edit button and no Delete button will be shown.

I hope this article helped you understand how to practically use RBAC in a React project. Please share it so others can benefit too. Follow me on [Twitter](https://twitter.com/dev__adi) and [Medium](http://medium.com/@adityaa803) to learn fun new things.


## What's next?

* Couple RBAC with dynamic imports. Webpack which is used by React under the hood does code splitting for dynamic imports automatically. So only the code that's required by currently logged in user is requested from the server.
* Implement RBAC on the server side using middlewares.
